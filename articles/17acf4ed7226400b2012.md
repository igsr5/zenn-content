---
title: "next/image はやっぱりすごかった - 機能紹介/パフォーマンス改善例/気をつけポイント"
emoji: "🔥"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Nextjs", "TypeScript", "JavaScript"]
published: false
---
先日、自身のポートフォリオサイトをリリースしました。
https://igsr5.dev

後からパフォーマンスチューニングの勉強をしたかったのであえて重たく実装したのですが、next/image を導入したところ想像以上にパフォーマンスが向上したのでブログにします。

## TL;DR
- next/image の機能紹介
  - next/image を導入すると勝手に色々いい感じになる
  - 画像フォーマット/サイズ最適化, Lazy load, 良さげなキャッシュ機構 etc...
- 実際に next/image を導入してみて前後のパフォーマンスを比べてみた
- 非常に優秀だが、気をつけポイントも存在する

※ 加工処理のパフォーマンスなどには触れていません

## next/image の機能をいくつか紹介
今回の next/image 導入で特に嬉しかった next/image の機能をいくつか紹介します。
他の機能については[公式ドキュメント](https://nextjs.org/docs/api-reference/next/image)に書いてあります。

### 画像フォーマット最適化
https://nextjs.org/docs/api-reference/next/image#acceptable-formats より
> The default Image Optimization API will automatically detect the browser's supported image formats via the request's Accept header.

next/image はブラウザのサポートする画像フォーマットをみて最適な画像フォーマットに変換してくれます。具体的には`Accept` ヘッダの値を見ているようです。

![webpが返ってきている](https://storage.googleapis.com/zenn-user-upload/fffb915aadcc-20220307.png)
この子たちは元は png, jpeg でしたが全員 webp に生まれ変わっています。(Chrome でアクセスした場合)

### 画像サイズ最適化

next/image に限らず、レイアウトシフトを避けるため img タグに width, height を指定した方が良いのは比較的知られた話ですが、next/image では width, height の指定が必須になっています。(`layout="fill"` を指定した場合を除く)
```jsx
<Image
  src={imgPath}
  width={700}
  height={475}
/>
```
しかし next/image におけるサイズ指定の恩恵はレイアウトシフトの対策だけではありません。他の恩恵として下記の2つが挙げられます。
- サーバサイドでの画像リサイズ
- 適切な画像サイズの算出

一つずつ説明していきます。

#### サーバサイドでの画像リサイズ
一つ目は「サーバサイドでの画像リサイズ」です。当たり前ですが通常の img タグだとサイズ指定をしても表示前にダウンロードする画像サイズはオリジナルのままです。next/image では自身で画像サーバを持っている（後述）のでサーバサイドで画像のリサイズを行うことができます。サーバサイドで画像リサイズが行われることによってダウンロードする画像サイズが減ることはサイト表示的にもユーザのネットワーク帯域的にも非常に嬉しいことです。

#### 適切な画像サイズの算出
二つ目は「適切な画像サイズの算出」です。初めて自分が見た時、「え？width も height も指定してるのに適切な画像サイズって何？」となりました。これは next/image のすごいところでもあり、気をつけポイントでもあるのですが、next/image では必ずしも指定したサイズの画像が返ってくるとは限りません。

next/image では画像の表示領域やユーザディスプレイの解像度に合わせて適切な画像サイズを返します。例えば高解像度の場合、指定したサイズよりも大きい画像サイズが変えるといった感じです。詳しい説明は [next/imageを仕事で使う際に気をつけたい仕様](https://zenn.dev/yukishinonome/articles/da315b1be98a9c) がとても参考になるのでそちらに譲ります。

個人的には img タグを利用するとき、width, height を指定した方がいいのは分かりつつ適切な画像サイズを考えるのが億劫で後回しにすることもあったので、このくらいの柔軟性を持たせつつ必須指定にしてくれたのはとてもありがたいです。もちろんケースによっては指定したサイズに正確にリサイズしてほしい時もあると思いますが、[`unoptimized`](https://nextjs.org/docs/api-reference/next/image#unoptimized) パラメータを有効にすればそういったケースにも対応できるので安心です。

該当公式ドキュメント
- https://nextjs.org/docs/api-reference/next/image#width
- https://nextjs.org/docs/api-reference/next/image#device-sizes


### Lazy Load
https://nextjs.org/docs/api-reference/next/image#loading より
> The loading behavior of the image. Defaults to lazy.

next/image ではデフォルトで Lazy Load が有効になっています。
特徴としては Native Lazy Loading ではなく JS Nazy Loading なので Safari 等のブラウザでも Lazy Load が有効である点です。（Safari が `loading` プロパティを早くサポートして欲しいというのはありますが、、）

![](https://storage.googleapis.com/zenn-user-upload/885a73075fc9-20220307.png)
iOS 15.3 の Safari で https://igsr5.dev/portfolio にアクセスした例。ちゃんと Lazy Load が動いているのが分かります。

現状 Safari で Lazy Load を有効にするためには JS Library を利用するしかありませんが、世の中の Lazy Load ライブラリは軒並み古いので next/image のような新しい機能でサポートしてくれるのも嬉しいポイントです。


### 良さげなキャッシュ機構
https://nextjs.org/docs/api-reference/next/image#caching-behavior
next/image が自身で持っている画像サーバ（後述）がいい感じに Cache-Control, Vary ヘッダをつけてくれます。
```ts
// https://github.com/vercel/next.js/blob/canary/packages/next/server/image-optimizer.ts#L619 より
res.setHeader('Vary', 'Accept')
res.setHeader(
  'Cache-Control',
  isStatic
    ? 'public, max-age=315360000, immutable'
    : `public, max-age=0, must-revalidate`
)
```

詳しい説明は省略しますが、static であれば基本イミュータブルなキャッシュとして、そうでなければ 最大TTL 0 かつ再検証必須化と [ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) の組み合わせで効率的にキャッシュを行ってくれます。

### 実際どうやって画像加工をしているの？
ここまでの内容で next/image はユーザ環境によって適切な画像サイズを算出したり、適切な画像フォーマットに変換することを説明してきました。これらはビルド時に画像を変換するだけでは実現できない機能たちです。では実際どのように next/image は画像加工を行っているのでしょうか。

#### Next.js が画像サーバを立ててそこから配信される

下記はnext/image を用いて画像を表示した時にimg タグに指定される画像URLの例です。
`https://igsr5.dev/_next/image?url=OOOO`

このURLの中にある `_next/image` が Next.js がデフォルトで持つ画像サーバです。この画像サーバがリクエスト毎に画像加工やキャッシュなどを行っています。反対にビルド時には画像の加工は行われておらず全てオンデマンドで行われています。

気をつけポイントとして Vercel 以外で Next.js をデプロイするときに `_next/image` もアクセス可能な状態にしておくことが挙げられます。（`_next/` 配下は他にも Next.js 的に大事なエンドポイントが詰まっているのでミスらないためには `_next/*` で公開してしまうのが良い気がします）

個人的にはオンデマンドな画像加工はキャッシュが効いているとはいえサーバサイドでのパフォーマンスが気になるので、一度時間のあるときに測ってみたいです。


## 実際に next/image でパフォーマンス改善を行ってみた
